package com.memento.flash.process {	public class PlayList {		// variables		public static const CONTINOUS_LIST:String  = "continousList";		public static const CONTINOUS_TRACK:String = "continousTrack";		public static const PLAY_ONCE:String       = "playOnce";		public var debug:String = "";		private var _playlist:Array;		private var _current:int;		private var _currentItem:Object;		private var _continousList:Boolean  = false;		private var _continousTrack:Boolean = false;		// instantiation		public function PlayList(items:Array = null):void {			_current  = -1;			_playlist = new Array();			if (items != null)				_playlist = _playlist.concat(items);		}		public function get list():Array {			return _playlist;		}		public function get length():uint {			return _playlist.length;		}		public function nextItem(force:Boolean = false):Object {			if (!_continousTrack || force) {				if (_continousList || force)					(_current < _playlist.length-1) ? (_current++) : (_current = 0);				else					(_current < _playlist.length-1) ? (_current++) : (_current = -1);			}			if (length > 0)				_currentItem = _playlist[_current];			else				_current = -1;			if (_current == -1)				return null;			else				return _current;		}		public function prevItem(force:Boolean = false):Object {			if (!_continousTrack || force) {				if (_continousList || force)					(_current > 0) ? (_current--) : (_current = _playlist.length-1);				else					(_current > 0) ? (_current--) : (_current = -1);;			}			if (_current == -1) {				return null;			}			else {				_currentItem = _playlist[_current];				return _current;			}		}		public function get currentItem():Object {			return _currentItem;		}		public function get selectionIndex():uint {			if (_current == -1) {				return 0;			}			else {				return _current;			}		}		public function selectItem(wich:int):Object {			if (length > 0) {				while (wich < 0)					wich += _playlist.length;				while (wich >= _playlist.length)					wich -= _playlist.length;				_current     = wich;				_currentItem = _playlist[_current];				return currentItem;			}			else {				return null;			}		}		public function addItems(items:Array, whereTo:*=null):void {			if (!whereTo)				whereTo = _playlist.length-1;			var i:uint     = 0;			var where:uint = 0;			if (items.length > 0) {				if (whereTo+1 <= _playlist.length) {					where = whereTo+1;					if (_current > where) _current += items.length;				}				else if (whereTo+1 > _playlist.length) {						where = _playlist.length;				}				for (i=0; i<items.length; i++) {					_playlist.splice(where, 0, items[i]);					where++;				}			}		}		public function moveItems(items:Array, howMany:int):void {			var moveArr:Array = new Array();			var tmp:Object;			var i:uint;			if (items.length == 0 || items.length  > _playlist.length || howMany == 0) {				return;			}			var direction:int = howMany/Math.abs(howMany);			(direction>0) ? items.sort(Array.DESCENDING) : items.sort(Array.NUMERIC);			for (i=0; i<items.length; i++) {				tmp       = new Object();				tmp.wich  = parseInt(items[i]);				tmp.where = tmp.wich + howMany;				if (tmp.where<0) tmp.where=0;				if (tmp.where>_playlist.length-1) tmp.where = _playlist.length-1;				moveArr.push(tmp);			}			debug = "";			while (moveArr.length>0) {				tmp = moveArr.splice(0, 1)[0];				// move element				//				var element:* = _playlist.splice(tmp.wich, 1)[0];				_playlist.splice(tmp.where, 0, element);				debug += "\nsplicing: " + tmp.wich.toString() + " -> " + tmp.where.toString();				var start:int = (direction > 0) ? (tmp.wich)  : (tmp.where);				var end:int   = (direction > 0) ? (tmp.where) : (tmp.wich);				// update remaining elements to drag				//				for each (var item in moveArr) {					if (item.wich >= start && item.wich <= end) {						item.wich += direction;					}				}				// update current				//				if (tmp.wich == _current) {					_current = tmp.where;					debug += "\ncurrent updated: " + _current.toString();				}				else if (_current >= start && _current <= end) {					_current -= direction;					debug += "\ncurrent updated: " + _current.toString();				}			}			debug += "\n - selection on: " + selectionIndex.toString();			trace(debug);		}		public function removeItems(remIndexes:Array):void {			var indexes:Array = remIndexes.sort(Array.DESCENDING);			for (var i:uint=0; i<indexes.length; i++) {				if ( (indexes[i] < _playlist.length) && (indexes[i] > -1) ) {					if (_current == indexes[i]) _current--;					_playlist.splice(indexes[i], 1);				}								}		}		public function clear():void {			_current  = -1;			_playlist = new Array();		}		public function switchContPlay(track:Boolean=false):void {			if (track) {				_continousTrack = ! _continousTrack;				_continousList  = false;			}			else {				_continousList  = ! _continousList;				_continousTrack = false;			}		}		public function get continousPlay():String {			if (_continousTrack) {				return(CONTINOUS_TRACK);			}			else if (_continousList) {				return(CONTINOUS_LIST);			}			else {				return(PLAY_ONCE);			}		}	}}