package com.memento.flash.display { 	import flash.display.*;	import flash.display.Graphics;	import flash.events.Event;		import flash.filters.*;	import flash.geom.*;			public dynamic class PerlinNoise extends MovieClip {		private var _desiredWidth:uint;		private var _desiredHeight:uint;		private var _shift:Matrix;		private var _speed:Number;		private var _noiseBitmap:BitmapData;		private var _displaceBitmap:BitmapData;		private var _displaceFilter:DisplacementMapFilter;		private var _perlin:Sprite;		private var _isRunning:Boolean = false;		private var _flapX:Number;		private var _flapY:Number;		private var _renderedLastFrame:Boolean = false;		public function PerlinNoise(bmpWidth:uint, bmpHeight:uint, fadeOnAdd:Boolean = false):void {			/*			Here, perlin noise is used to create random waves in 			a movie clip that is used as a displacement map for a			another movie clip making it appear as though it is waving			*/			_desiredWidth  = bmpWidth;			_desiredHeight = bmpHeight;			_shift         = new Matrix();			_perlin        = new Sprite();			//addChild(_perlin);			// place ramp above perlin noise			// ** 50% red is no displacement in the displacement map			// the ramp goes from 50% red to transparent letting			// the perlin noise show through as you move further right			// GENERAL variables			// speed at which noise is shifted (causes flap)			_speed = 3;			_displaceBitmap = new BitmapData(_desiredWidth, _desiredHeight, true);			strength = 20;			// red - red used to displace pixels along			var channel:uint = 1;			// size of noise in x axis			var baseX:Number = 400;			// size of noise in y axis			var baseY:Number = 75;			// noise functions for noise (smaller = faster)			var octs:uint = 1;			// random seed for noise			var seed:uint = Math.floor(Math.random()*5);			// stitching makes the noise wrap making it easy to repeat			var stitch:Boolean = true;			// use fractal noise			var fractal:Boolean = true;			// grayscale is not used because we want the red channel			var gray:Boolean = false;			// create BitmapData object for the noise and apply perlinNoise.  It will be repeated			// along y so it  only needs to be 1 pixel high.  How long it is determines the			// variants of noise produced.  With the stitching and thanks to beginGradientFill,			// we will just loop the noise over time.			_noiseBitmap = new BitmapData(_desiredWidth, _desiredHeight);			_noiseBitmap.perlinNoise(baseX, baseY, octs, seed, stitch, fractal, channel, gray);			if (fadeOnAdd) {				addEventListener(Event.ADDED_TO_STAGE,					function(event:Event):void {						transform.colorTransform = new ColorTransform(1, 1, 1, 0);						addEventListener(Event.ENTER_FRAME, perlinFadeIn);					}				);			}		}		private function animate(event:Event):void {			// move the matrix by speed along x to shift the noise			_shift.translate(0, _speed);			// drawing in the perlin movie clip,			// create a rectangle with the perlin noise			// drawn in it with an offset supplied by the			// shift matrix			with (_perlin.graphics) {				clear();				beginBitmapFill(_noiseBitmap, _shift, true, true);				drawRect(0, 0, _desiredWidth, _desiredHeight)				endFill();			}			// draw the displacement movie clip in the 			// displaceBitmap (used in displaceFilter)			_displaceBitmap.draw(_perlin);			// apply displaceFilter to the flag			_displaceFilter.scaleX = 0//_flapX;			_displaceFilter.scaleY = 0//_flapY;			filters = [_displaceFilter];		}		public function startAnim():void {			_isRunning    = true;			addEventListener(Event.ENTER_FRAME, animate);		}		public function stopAnim():void {			_isRunning = false;			removeEventListener(Event.ENTER_FRAME, animate);			filters = [];		}		public function get isRunning():Boolean {			return _isRunning;		}		public function set strength(myStrength:Number):void {			// red - red used to displace pixels along			var channel:uint = 1;			// power of pixel displacement along x axis			_flapX = myStrength;			// power of pixel displacement along y axis			_flapY = myStrength;			// clamp the image so none of the original is seen			// ** inside the flag movie clip there is an invisible border that is			// used to extend the bounds of the clip beyond that of the flag image			// this lets the displacement map extend further past the extents of the flag			var mode:String = 'clamp';			// displacment map offset			var offset:Point = new Point(0, 0);			_displaceFilter = new DisplacementMapFilter(_displaceBitmap, offset, channel, channel, _flapX, _flapY, mode);		}		public function get strength():Number {			return _flapX;		}		// for animation		//		private function perlinFadeIn(event:Event):void {			var myPerlin:PerlinNoise          = event.currentTarget as PerlinNoise;			myPerlin.transform.colorTransform = new ColorTransform(1, 1, 1, myPerlin.alpha + 0.03);			myPerlin.strength                 = ((1 - myPerlin.alpha) * 70) > 0 ? Math.round((1 - myPerlin.alpha) * 50) : 0;			if (myPerlin.alpha > 1 && !myPerlin.renderedLastFrame) {				myPerlin.transform.colorTransform = new ColorTransform(1, 1, 1, 1);				_renderedLastFrame                = true;			}			else if (_renderedLastFrame) {						var target:Sprite = myPerlin.parent as Sprite;				var childNum:uint = target.getChildIndex(myPerlin);				for (var i:uint=0; i<childNum; i++) target.removeChildAt(0);						myPerlin.stopAnim();				_renderedLastFrame = false;						myPerlin.removeEventListener(Event.ENTER_FRAME, perlinFadeIn);			}			else if (!myPerlin.isRunning) {				myPerlin.startAnim();			}		}	}}